// Copyright 2024 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

// Unit tester for the Arm64 Assembler. You don't want to run this file alone,
// but execute it via test.bash.

// We test many permutations of arguments for each instruction by doing the following:
// 1. Emit assembly for the instructions we want to test, compile the assembly,
// and objdump it to view the opcodes.
// 2. Emit a corresponding virgil objdump file, which looks exactly the same,
// but with virgil opcodes our assembly produces
// 3. Diff the two objdump files

// File containing one assembly instruction per line.
var asmFd = 0;
// File containing corresponding opcodes we produce of assembly instructions
var opcodeFd = 0;

def data = DataWriter.new();
var asm = Arm64Assembler.new(data);
var buf = StringBuilder.new();
var lineNum = 0;

var args: Array<string>;
// Mutable variable indicating what size register we render for assembly instructions
// either 64-bit or 32-bit

def main(a: Array<string>) -> int {
	if (a.length < 2) {
		System.error("TestGenError", "Temporary file path argument missing");
	}

	args = a;
	def asmPath = a[0];
	def opcodePath = a[1];
	def objectPath = a[2];
	asmFd = System.fileOpen(asmPath, false);
	opcodeFd = System.fileOpen(opcodePath, false);

	writeObjdumpHeader(objectPath, opcodeFd);

	test_mov();
	test_add();
	test_sub();
	test_cmp();
	test_mul();
	test_div();

	buf.puts(";;passed");
	System.fileWriteK(asmFd, buf.buf, 0, buf.length);
	buf.reset();
	return 0;
}

// Returns true if we should skip testing this instruction
def skip(mnemonic: string) -> bool {
	if (args.length == 3) return false;
	for (i = 3; i < args.length; i++) {
		if (Strings.startsWith(mnemonic, args[i])) return false;
	}
	return true;
}

def writeObjdumpHeader(objectPath: string, opcodeFd: int) {
	buf.ln();
	buf.puts(Strings.builderOf(objectPath).puts(":\tfile format mach-o arm64\n\n").toString());
	buf.puts("Disassembly of section __TEXT,__text:\n\n");
	buf.puts("0000000000000000 <ltmp0>:\n");
	System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
	buf.reset();
}

def reverse(s: string) -> string {
	def r = string.new(s.length);
	for (i < s.length) {
		r[i] = s[s.length - i - 1];
	}
	return r;
}

// Converts byte to lower case if it is a lower case char
def toLowerCase(b: byte) -> byte {
	if (65 <= b && b <= 90) return byte.view(b + 32);
	return b;
}

def toHexString(x: int) -> string {
	if (x == 0) return "0";
	def hex_digits = "0123456789abcdef";
	def result = StringBuilder.new();

	while (x > 0) {
		def remainder = x % 16;
		result.putc(hex_digits[remainder]);
		x /= 16;
	}
	return reverse(result.toString());
}

// Extracts opcode from dataWriter into buffer with new line and flushes it to opcode file
// Resets dataWriter and buffer
def writeOpcode() {
	def hexString = toHexString(lineNum * 4);
	lineNum++;
	def numSpaces = 8 - hexString.length;

	// Write line number
	for (i < numSpaces) buf.puts(" ");
	buf.puts(hexString).puts(":");

	for (i < data.pos) {
		buf.puts(" ");
		buf.putx_8(data.data[i]);
		buf.buf[buf.length - 1] = toLowerCase(buf.buf[buf.length - 1]);
		buf.buf[buf.length - 2] = toLowerCase(buf.buf[buf.length - 2]);
	}

	data.at(0);
	System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
	buf.reset();
}

// Tests an instruction with no arguments
// mnemonic - instruction to test
// emitAsm - emit opcode to DataWriter of instruction to test
def testNoArgs(mnemonic: string, emitAsm: void -> Arm64Assembler) {
	emitAsm();
	writeOpcode();
	buf.sp().sp().tab().puts(mnemonic);
	System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
	System.fileWriteK(asmFd, buf.buf, 0, buf.length);
	buf.reset();
}

// Tests an instruction with one argument
// mnemonic - instruction to test
// args - array of instruction args and function to print them to buf
// emitAsm - emit opcode to DataWriter of instruction to test
def testOneArg<A>(mnemonic: string,
	emitAsm: A -> Arm64Assembler,
	args: (Array<A>, A -> void)) {
	if (skip(mnemonic)) return;
	for (a in args.0) {
		emitAsm(a);
		writeOpcode();
		buf.sp().sp().tab().puts(mnemonic).tab();
		args.1(a);
		System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
		System.fileWriteK(asmFd, buf.buf, 0, buf.length);
		buf.reset();
	}
}

// Tests an instruction with two arguments
// mnemonic - instruction to test
// args - array of instruction args and function to print them to buf
// emitAsm - emit opcode to DataWriter of instruction to test
def testTwoArgs<A, B>(mnemonic: string,
	emitAsm: (A, B) -> Arm64Assembler,
	args1: (Array<A>, A -> void),
	args2: (Array<B>, B -> void)) {
	if (skip(mnemonic)) return;
	for (a in args1.0) {
		for (b in args2.0) {
			emitAsm(a, b);
			writeOpcode();
			buf.sp().sp().tab().puts(mnemonic).tab();
			args1.1(a);
			buf.csp();
			args2.1(b);
			buf.ln();
			System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
			System.fileWriteK(asmFd, buf.buf, 0, buf.length);
			buf.reset();
		}
	}
}

// Tests an instruction with three
// mnemonic - instruction to test
// args - array of instruction args and function to print them to buf
// emitAsm - emit opcode to DataWriter of instruction to test
def testThreeArgs<A, B, C>(mnemonic: string,
	emitAsm: (A, B, C) -> Arm64Assembler,
	args1: (Array<A>, A -> void),
	args2: (Array<B>, B -> void),
	args3: (Array<C>, (B, C) -> void)) {
	if (skip(mnemonic)) return;
	for (a in args1.0) {
		for (b in args2.0) {
			for (c in args3.0) {
				emitAsm(a, b, c);
				writeOpcode();
				buf.sp().sp().tab().puts(mnemonic).tab();
				args1.1(a);
				buf.csp();
				args2.1(b);
				args3.1(b, c);
				buf.ln();
				System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
				System.fileWriteK(asmFd, buf.buf, 0, buf.length);
				buf.reset();
			}
		}
	}
}

// Tests an instruction with four arguments
// mnemonic - instruction to test
// args - array of instruction args and function to print them to buf
// emitAsm - emit opcode to DataWriter of instruction to test
def testFourArgs<A, B, C, D>(mnemonic: string,
	emitAsm: (A, B, C, D) -> Arm64Assembler,
	args1: (Array<A>, A -> void),
	args2: (Array<B>, B -> void),
	args3: (Array<C>, C -> void),
	args4: (Array<D>, (C, D) -> void)) {
	if (skip(mnemonic)) return;
	for (a in args1.0) {
		for (b in args2.0) {
			for (c in args3.0) {
				for (d in args4.0) {
					emitAsm(a, b, c, d);
					writeOpcode();
					buf.sp().sp().tab().puts(mnemonic).tab();
					args1.1(a);
					buf.csp();
					args2.1(b);
					buf.csp();
					args3.1(c);
					args4.1(c, d);
					buf.ln();
					System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
					System.fileWriteK(asmFd, buf.buf, 0, buf.length);
					buf.reset();
				}
			}
		}
	}
}

// Tests an instruction with five arguments
// are space separated.
// mnemonic - instruction to test
// args - array of instruction args and function to print them to buf
// emitAsm - emit opcode to DataWriter of instruction to test
def testFiveArgs<A, B, C, D, E>(mnemonic: string,
	emitAsm: (A, B, C, D, E) -> Arm64Assembler,
	args1: (Array<A>, A -> void),
	args2: (Array<B>, B -> void),
	args3: (Array<C>, (C, D) -> void),
	args4: (Array<D>, D -> void),
	args5: (Array<E>, E -> void)) {
	if (skip(mnemonic)) return;
	for (a in args1.0) {
		for (b in args2.0) {
			for (c in args3.0) {
				for (d in args4.0) {
					for (e in args5.0) {
						emitAsm(a, b, c, d, e);
						writeOpcode();
						buf.sp().sp().tab().puts(mnemonic).tab();
						args1.1(a);
						buf.csp();
						args2.1(b);
						buf.csp();
						args3.1(c, d);
						buf.csp();
						args4.1(d);
						buf.sp();
						args5.1(e);
						buf.ln();
						System.fileWriteK(opcodeFd, buf.buf, 0, buf.length);
						System.fileWriteK(asmFd, buf.buf, 0, buf.length);
						buf.reset();
					}
				}
			}
		}
	}
}

// A bunch of rendering functions so that we can match instructions we assemble
// to mnemonics that `as` uses
def renderSfr(r: Arm64Sfr) { buf.puts(r.name); }
def renderGpr64(r: Arm64Gpr) { buf.puts(r.name64); }
def renderGpr32(r: Arm64Gpr) { buf.puts(r.name32); }
def renderGprGpr32(q: Arm64Gpr, r: Arm64Gpr) { buf.csp().puts(r.name32); }
def renderGprGpr64(q: Arm64Gpr, r: Arm64Gpr) { buf.csp().puts(r.name64); }
def renderExtendedReg(r: Arm64Gpr, ex: RegExtend) {
	match (ex) {
		UXTX, SXTX => buf.puts(r.name64);
		_ => buf.puts(r.name32);
	}
}
def renderShiftedGpr32(r: Arm64Gpr, sh: RegShift) { buf.puts(r.name32); }
def renderShiftedGpr64(r: Arm64Gpr, sh: RegShift) { buf.puts(r.name64); }

// A bunch of operation arguments
def u16s: Array<u16> = [0, 1, 2, u16.view(-1), u16.view(-2), u16.view(-128), 96, 127, 128, 1023,
	u16.view(-999), 32767, u16.view(-32768)];
def u12s: Array<u12> = [0x03A, 0x0F2, 0x0BA, 0x0C4];
def u6s: Array<u6> = [0x0A, 0x1E, 0x2C, 0x1B, 0x3A];
def u5s: Array<u5> = [0x0A, 0x1E, 0x0B, 0x17, 0x0F];
def u3s: Array<u3> = [0, 1, 2, 3, 4]; // extend ops only take 0 - 4, not all u3s.
def u1s: Array<u1> = [0, 1];
def shifts = [RegShift.LSL, RegShift.LSR, RegShift.ASR]; // TODO: ROR?
def regExtends = [RegExtend.SXTB, RegExtend.SXTH, RegExtend.SXTW,
	RegExtend.UXTB, RegExtend.UXTH, RegExtend.UXTW];
def rand_regs: Array<Arm64Gpr> = [Arm64Regs.R0, Arm64Regs.R10, Arm64Regs.R21, Arm64Regs.R30];

def renderU16(i: u16) { buf.puts("#").putd(u32.view(i)); }
def renderU12(i: u12) { buf.puts("#").putd(u32.view(i)); }
def renderU6(i: u6) { buf.puts("#").putd(u32.view(i)); }
def renderU6Shift(sh: RegShift, i: u6) { buf.puts(" #").putd(u32.view(i)); }
def renderU5(i: u5) { buf.puts("#").putd(u32.view(i)); }
def renderU5Shift(sh: RegShift, i: u5) { buf.puts(" #").putd(u32.view(i)); }
def renderU3(i: u3) { 
	if (i != 0) {
		buf.puts("#").putd(u32.view(i));
	}
}
// U1s are indicators on shifting left 12 for data
def renderU1(imm: u12, i: u1) {
	if (i == 1) {
		buf.csp().puts("lsl #12").tab().puts("; =").putd(u32.view(imm) << 12);
	}
}

def renderShift(sh: RegShift) { buf.puts(sh.name); }
def renderExtend(ex: RegExtend) { buf.puts(ex.name); }

// Arguments to assembly instructions paired with a function to print them to buf
def arg_r32 = (rand_regs, renderGpr32);
def arg_r64 = (rand_regs, renderGpr64);
def arg_r0 = ([Arm64Regs.R0], renderGpr32);
def arg_u16 = (u16s, renderU16);
def arg_u12 = (u12s, renderU12);
def arg_u6 = (u6s, renderU6);
def arg_u6_shift = (u6s, renderU6Shift);
def arg_u5 = (u5s, renderU5);
def arg_u5_shift = (u5s, renderU5Shift);
def arg_u3 = (u3s, renderU3);
def arg_u1 = (u1s, renderU1);
def arg_shift = (shifts, renderShift);
def arg_extend = (regExtends, renderExtend);
def arg_r_extend = (rand_regs, renderExtendedReg);
def arg_r32_shift = (rand_regs, renderShiftedGpr32);
def arg_r64_shift = (rand_regs, renderShiftedGpr64);
def arg_r32_reg = (rand_regs, renderGprGpr32);
def arg_r64_reg = (rand_regs, renderGprGpr64);

// Testing functions that take in a mnemonic and a corresponding assembler function
def testd_r_u16 = testTwoArgs(_, _, arg_r32, arg_u16);
def testq_r_u16 = testTwoArgs(_, _, arg_r64, arg_u16);
def testd_r_r = testTwoArgs(_, _, arg_r32, arg_r32);
def testq_r_r = testTwoArgs(_, _, arg_r64, arg_r64);
def testd_r_i_i = testThreeArgs(_, _, arg_r32, arg_u12, arg_u1);
def testq_r_i_i = testThreeArgs(_, _, arg_r64, arg_u12, arg_u1);
def testd_r_r_r = testThreeArgs(_, _, arg_r32, arg_r32, arg_r32_reg);
def testq_r_r_r = testThreeArgs(_, _, arg_r64, arg_r64, arg_r64_reg);
def testd_r_r_i_i = testFourArgs(_, _, arg_r32, arg_r32, arg_u12, arg_u1);
def testq_r_r_i_i = testFourArgs(_, _, arg_r64, arg_r64, arg_u12, arg_u1);
def testd_r_r_sh_i = testFourArgs(_, _, arg_r32, arg_r32, arg_shift, arg_u5_shift);
def testq_r_r_sh_i = testFourArgs(_, _, arg_r64, arg_r64, arg_shift, arg_u6_shift);
def testd_r_r_r_sh_i = testFiveArgs(_, _, arg_r32, arg_r32, arg_r32_shift, arg_shift, arg_u5);
def testq_r_r_r_sh_i = testFiveArgs(_, _, arg_r64, arg_r64, arg_r64_shift, arg_shift, arg_u6);
def testd_r_r_r_ex_i = testFiveArgs(_, _, arg_r32, arg_r32, arg_r_extend, arg_extend, arg_u3);
def testq_r_r_r_ex_i = testFiveArgs(_, _, arg_r64, arg_r64, arg_r_extend, arg_extend, arg_u3);

// Testing functions for specific assembly instructions
def test_mov() {
	testd_r_u16("mov", asm.movd_r_i);
	testq_r_u16("mov", asm.movq_r_i);
	testd_r_r("mov", asm.movd_r_r);
	testq_r_r("mov", asm.movq_r_r);
}

def test_add() {
	testd_r_r_i_i("add", asm.addd_r_r_i_i);
	testq_r_r_i_i("add", asm.addq_r_r_i_i);
	testd_r_r_r_sh_i("add", asm.addd_r_r_r_sh_i);
	testq_r_r_r_sh_i("add", asm.addq_r_r_r_sh_i);
	testd_r_r_r_ex_i("add", asm.addd_r_r_r_ex_i);
	testq_r_r_r_ex_i("add", asm.addq_r_r_r_ex_i);
}

def test_sub() {
	testd_r_r_i_i("sub", asm.subd_r_r_i_i);
	testq_r_r_i_i("sub", asm.subq_r_r_i_i);
	testd_r_r_r_sh_i("sub", asm.subd_r_r_r_sh_i);
	testq_r_r_r_sh_i("sub", asm.subq_r_r_r_sh_i);
	testd_r_r_r_ex_i("sub", asm.subd_r_r_r_ex_i);
	testq_r_r_r_ex_i("sub", asm.subq_r_r_r_ex_i);
}

def test_cmp() {
	testd_r_r_sh_i("cmp", asm.cmpd_r_r_sh_i);
	testq_r_r_sh_i("cmp", asm.cmpq_r_r_sh_i);
	testd_r_i_i("cmp", asm.cmpd_r_i_i);
	testq_r_i_i("cmp", asm.cmpq_r_i_i);
}

def test_mul() {
	testd_r_r_r("mul", asm.muld_r_r_r);
	testq_r_r_r("mul", asm.mulq_r_r_r);
}

def test_div() {
	testd_r_r_r("sdiv", asm.sdivd_r_r_r);
	testq_r_r_r("sdiv", asm.sdivq_r_r_r);
	testd_r_r_r("udiv", asm.udivd_r_r_r);
	testq_r_r_r("udiv", asm.udivq_r_r_r);
}
