// Copyright 2024 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def Regs: Arm64Regs;

class Arm64AddrPatcher {
	def mw: MachDataWriter;
	def asm: Arm64MacroAssembler;
	def ABS_IMM16_MARKER: u16 = 0x3388;
	def REL_IMM26_MARKER: u26 = 0xDD2341;

	new(mw, asm) {}

	def record(addr: Addr) {
		mw.recordArm64Patch(addr, asm.patchKind, asm.patchPos);
	}

	def patch(kind: Arm64PatchKind, posAddr: int, absAddr: int) {
		def pos = mw.pos;
		match (kind) {
			ABS_IMM16 => asm.patch_ABS_i16(pos, u16.view(absAddr));
			REL_IMM26 => asm.patch_REL_i26(pos, i26.view((absAddr - posAddr) / 4));
			_ => unknownPatchKind();
		}
	}

	def unknownPatchKind() {
		return V3.fail("Arm64AddrPatcher Encountered Unknown Patch Kind");
	}
}

// Adds additional functionality to the base Arm64 assembler.
// - Supports instructions with address operands.
// - Supports instructions that emit multiple Arm instructions. For example,
// data operations with immediates in Arm only allow small immediates. Here
// we can support an addition with any sized immediate by casing on the size
// and emitting multiple Arm64 instructions in some cases.
class Arm64MacroAssembler extends Arm64Assembler {
	def mw: MachDataWriter;
	var patcher: Arm64AddrPatcher;

	new(mw) super(mw) {
		patcher = Arm64AddrPatcher.new(mw, this);
	}

	def bl_a(a: Addr) -> this {
		bl_i(patcher.REL_IMM26_MARKER);
		patcher.record(a);
	}

	def movd_r_a_a(rd: Arm64Gpr, low16: Addr, high16: Addr) -> this {
		asm.movd_r_i16(rd, asm.patcher.ABS_IMM16_MARKER);
		asm.patcher.record(low16);
		// Move high 16 bits of table addr
		asm.movkd_r_i16_u1(rd, asm.patcher.ABS_IMM16_MARKER, 1);
		asm.patcher.record(high16);
	}

	def movd_r_i32(rd: Arm64Gpr, imm: int) -> this {
		if (short.?(imm)) {
			movd_r_i16(rd, short.!(imm));
		} else {
			low16 = imm & 0xFF;
			high16 = (imm & 0xFF00) >> 16;
			movd_r_i16(rd, short.!(low16));
			movkd_r_i16(rd, short.!(high16));
		}
	}

	def movq_r_i64(rd: Arm64Gpr, imm: long) -> this {
		if (short.?(imm)) {
			movd_r_i16(rd, short.!(imm));
		} else if (int.?(imm)) {
			low16 = imm & 0xFF;
			high16 = (imm & 0xFF00) >> 16;
			movd_r_i16(rd, short.!(low16));
			movkd_r_i16_u1(rd, short.!(high16), 1);
		} else if (i48.?(imm)) {
			low16 = imm & 0xFF;
			mid16 = (imm & 0xFF00) >> 16;
			high16 = (imm & 0xFF0000) >> 32;
			movd_r_i16(rd, short.!(low16));
			movkd_r_i16_u1(rd, short.!(mid16), 1);
			movkq_r_i16_u2(rd, short.!(mid16), 2);	
		} else {
			low16 = imm & 0xFF;
			midLow16 = (imm & 0xFF00) >> 16;
			midHigh16 = (imm & 0xFF0000) >> 32;
			high16 = (imm & 0xFF000000) >> 48;
			movd_r_i16(rd, short.!(low16));
			movkd_r_i16_u1(rd, short.!(midLow16), 1);
			movkq_r_i16_u2(rd, short.!(midHigh16), 2);	
			movkq_r_i16_u2(rd, short.!(high16), 3);	
		}
	}

	def addd_r_r_i32_u1(rd: Arm64Gpr, rn: Arm64Gpr, imm: int, lsl12: u1) -> this {
		if (i12.?(imm)) addd_r_r_i12_u1(rd, rn, i12.!(imm), lsl12);
		else {
			movd_r_i32(Regs.IP1, imm);
			addd_r_r_r_sh_u5(rd, rn, Regs.IP1, RegShift.LSL, 0);
		}
	}

	def addq_r_r_i64_u1(rd: Arm64Gpr, rn: Arm64Gpr, imm: long, lsl12: u1) -> this {
		if (i12.?(imm)) addq_r_r_i12_u1(rd, rn, i12.!(imm), lsl12);
		else {
			movq_r_i64(Regs.IP1, imm);
			addq_r_r_r_sh_u6(rd, rn, Regs.IP1, RegShift.LSL, 0);
		}
	}

	def subd_r_r_i32_u1(rd: Arm64Gpr, rn: Arm64Gpr, imm: int, lsl12: u1) -> this {
		if (i12.?(imm)) subd_r_r_i12_u1(rd, rn, i12.!(imm), lsl12);
		else {
			movd_r_i32(Regs.IP1, imm);
			subd_r_r_r_sh_u5(rd, rn, Regs.IP1, RegShift.LSL, 0);
		}
	}

	def subq_r_r_i64_u1(rd: Arm64Gpr, rn: Arm64Gpr, imm: long, lsl12: u1) -> this {
		if (i12.?(imm)) subq_r_r_i12_u1(rd, rn, i12.!(imm), lsl12);
		else {
			movq_r_i64(Regs.IP1, imm);
			subq_r_r_r_sh_u6(rd, rn, Regs.IP1, RegShift.LSL, 0);
		}
	}

	def ldrd_r_r_i32(rt: Arm64Gpr, rn: Arm64Gpr, imm: int) -> this {
		if (i9.?(imm)) ldrd_r_r_i9(rt, rn, i9.!(imm));
		else {
			movd_r_i32(Regs.IP1, imm);
			ldrd_r_r_r_ex_i(rt, rn, Regs.IP1, MemRegExtend.LSL, 0);
		}
	}

	def ldrq_r_r_i32(rt: Arm64Gpr, rn: Arm64Gpr, imm: int) -> this {
		if (i9.?(imm)) ldrq_r_r_i9(rt, rn, i9.!(imm));
		else {
			movd_r_i64(Regs.IP1, imm);
			ldrq_r_r_r_ex_i(rt, rn, Regs.IP1, MemRegExtend.LSL, 0);
		}
	}

	def strd_r_r_i32(rt: Arm64Gpr, rn: Arm64Gpr, imm: int) -> this {
		if (i9.?(imm)) strd_r_r_i9(rt, rn, i9.!(imm));
		else {
			movq_r_i32(Regs.IP1, imm);
			strd_r_r_r_ex_i(rt, rn, Regs.IP1, MemRegExtend.LSL, 0);
		}
	}

	def strq_r_r_i32(rt: Arm64Gpr, rn: Arm64Gpr, imm: int) -> this {
		if (i9.?(imm)) strq_r_r_i9(rt, rn, i9.!(imm));
		else {
			movd_r_i64(Regs.IP1, imm);
			strq_r_r_r_ex_i(rt, rn, Regs.IP1, MemRegExtend.LSL, 0);
		}
	}
}