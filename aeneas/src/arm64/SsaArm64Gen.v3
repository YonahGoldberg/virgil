// Arm64 instructions are ints that look like <variant><mode arg><mode><code>
// where each part of the instruction is a byte

// codes
def MASK_CODE = 0xff;
def I_ADD = 0x00;
def I_MOV = 0x01;
def I_MOVK = 0x02;

// addressing modes
def MASK_AM = 0xff00;
def SHIFT_AM: byte = 8;
def AM_NONE = 0x00;
def AM_IMM = 0x01;
def AM_SHIFTED_IMM = 0x02;
def AM_EXTENDED_REG_LSL = 0x03;
def AM_SHIFTED_REG_LSL = 0x04;
def AM_REG = 0x05;

// addressing mode args
def MASK_AM_ARG = 0xff0000;
def SHIFT_AM_ARG: byte = 16;
def ARG_NONE = 0x00;

// variants (the width of the type the instruction operates on)
def MASK_VARIANT = 0xff000000;
def SHIFT_VARIANT: byte = 24;
def V_32 = 0x00;
def V_64 = 0x01;

// XXX: Add to utils?
type Maybe<T> {
	case None;
	case Some(t: T);
}

// The possible widths of immediates used in Arm64 instructions
type ImmWidth {
	case Imm12;
	case Imm16;
	case Imm19;
}

// Constructs an opcode from the 4 parts
def makeOpcode(code: int, am: int, amArg: int, variant: int) -> int {
	return code | (am << SHIFT_AM) | (amArg << MASK_AM_ARG) | (variant << SHIFT_VARIANT);
}

// Extracts the code section of the opcode
def getCode(opcode: int) -> int {
    return op & MASK_CODE;
}

// Inserts the code section of the opcode
def putOpcode(opcode: int, code: int) -> int {
    return opcode | code;
}

// Extracts the addressing mode argument section of the opcode
def getAmArg(opcode: int) -> int {
    return (opcode & MASK_AM_ARG) >> SHIFT_AM_ARG;
}

// Inserts the addressing mode argument section of the opcode
def putAmArg(opcode: int, arg: int) -> int {
    return (arg << SHIFT_AM_ARG) | opcode;
}

// Extracts the addressing mode section of the opcode
def getAm(opcode: int) -> int {
    return (opcode & MASK_AM) >> SHIFT_AM;
}

// Inserts the addressing mode section of the opcode
def putAm(opcode: int, am: int) -> int {
    return (am << SHIFT_AM) | opcode;
}

// Inserts the variant section of the opcode
def getVariant(opcode: int) -> int {
    return (opcode & MASK_VARIANT) >> SHIFT_VARIANT;
}

// Extracts the variant section of the opcode
def putVariant(opcode: int, variant: int) -> int {
    return (variant << SHIFT_VARIANT) | opcode;
}

// Inserts the variant section of the opcode according to the register class
// of the operands
def putRegClassVariant(opcode: int, rc: RegClass) -> int {
	match (rc) {
		I32, F32 => return (V_32 << SHIFT_VARIANT) | opcode;
		_ => return (V_64 << SHIFT_VARIANT) | opcode;
	}
}

def Regs: Arm64RegSet;
def Conds: Arm64Conds; // TODO

// Code generation for the Arm64 backend
class SsaArm64Gen extends SsaMachGen {
	def asm: Arm64MacroAssembler; // TODO
	def m = SsaInstrMatcher.new();

    new(context: SsaContext, mach: MachProgram, asm, w: MachDataWriter)
        super(context, mach, Arm64RegSet.SET, w) {}

    // Overidden Architecture Specific Routines
    def visitApply(block: SsaBlock, i: SsaApplyOp) {
        match (i.op.opcode) {
            IntAdd => {
                emitIntBinop(I_ADD, i);
            }
			_ => context.fail("not implemented"); // TODO
        }
    }

	def visitThrow(block: SsaBlock, i: SsaThrow) { context.fail("not implemented"); }
	def visitIf(block: SsaBlock, i: SsaIf) { context.fail("not implemented"); }
	def visitSwitch(block: SsaBlock, i: SsaSwitch) { context.fail("not implemented"); }
	def visitGoto(block: SsaBlock, target: SsaGoto) { context.fail("not implemented"); }

    // Override Code Generation
	def assemble(opcode: int, x: Array<Operand>);
    	def getOutput() -> ArchInstrBuffer {
		if (out != null) return out;
		return out = Arm64InstrBuffer.new(this, context.prog, regSet); // TODO
	}

    // Regalloc callbacks to add moves
    def genSaveLocal(reg: int, v: VReg) { context.fail("not implemented"); }
	def genRestoreLocal(v: VReg, reg: int) { context.fail("not implemented"); }
	def genMoveLocLoc(src: (VReg, int), dst: (VReg, int), regClass: RegClass) { context.fail("not implemented"); }

	// Register allocation callback to prepend a move
	def genMoveValLoc(src: VReg, dst: (VReg, int), regClass: RegClass) {
		def operand = getImm32Operand(src.ssa, ImmWidth.Imm16);
		if (regSet.isStack(dst.1)) {
			match (operand) {
				Some(immOp) => {
					// Move constant directly to stack
					emit2(putRegClassVariant(I_MOV, regClass), dfnv0(dst), op(immOp));
				}
				None => {
					// Too large constant or mem loc, either way need scratch
					genMoveValLoc(src, (null, Regs.SCRATCH_GPR), regClass);
					genMoveValLoc((null, Regs.SCRATCH_GPR), dst, regClass);
				}
			}
		} else {
            // TODO dst can be an xmm
            match (operand) {
                Some(immOp) => {
                    // Move constant directly to reg
                    emit2(putRegClassVariant(I_MOV, regClass), dfnv0(dst), op(immOp));
                }
                None => {
                    // Constant too large
                    def val = SssaConst.!(src.ssa).val;
                    match (val) {
                        x: Box<int> => {
                            if (x.val == i16.view(x.val)) {
                                // Arm64 mov supports 16-bit immediates
                                emit2(putVariant(I_MOV, V_32), dfnv(null, Regs.SCRATCH_GPR), useImm(val));
                            } else {
                                // mov followed by movk to insert imm in reg
                                // move first 16-bits to reg
                                emit2(putVariant(I_MOV, V_32), dfnv(null, Regs.SCRATCH_GPR), Int.box(x.val & 0xffff));
                                // Move second 16-bits to reg
                                def opcode = makeOpcode(I_MOVK, AM_SHIFTED_IMM, 16, V_32);
                                emit2(opcode, dfnv(null, Regs.SCRATCH_GPR), Int.box((x.val & 0xffff0000) >> 16));
                            }
                        }
                        _ => context.fail("not implemented"); // TODO
                    }
                }
            }
		}
	}

    // Helper functions
    // Emit code for an integer binop
    def emitIntBinop(code: int, i: SsaApplyOp) {
        def variant = getIntOpVariant(i);
		emitSimpleBinop(code, variant, i);
	}

	// Emit code for a simple binop (add, sub, mul, etc...)
    def emitSimpleBinop(code: int, variant: int, i: SsaApplyOp, maxImmWidth: ImmWidth) {
		// XXX: select better left operand using liveness
        m.intbinop(i);
		match (getImm32Operand(m.y, maxImmWidth)) {
			Some(immOp) => {
				def opcode = makeOpcode(code, AM_IMM, ARG_NONE, variant);
				emit3(opcode, dfnReg(i), use(m.x), use(immOp));
			}
			None => {
				// if y is imm and too large to fit in binop, we use a
				// const VReg. Regalloc later calls back `genMoveValLoc` to move
				// y to reg.
				def opcode = makeOpcode(code, AM_REG, ARG_NONE, variant);
				emit3(opcode, dfnReg(i), use(m.x), use(m.y));
			}
		}
	}

	// Returns the variant for an integer operation
	def getIntOpVariant(i: SsaApplyOp) -> byte {
		// XXX: factor this out and clean it up
		def t = i.op.typeArgs[0];
        var width: int;

		if (IntType.?(t)) width = IntType.!(t).width;
		else if (t.typeCon.kind == V3Kind.ENUM) width = V3.getVariantTagType(t).width;
		else if (t.typeCon.kind == V3Kind.ENUM_SET) width = V3.getEnumSetType(t).width;
        else width = 64;

        return if(width > 32, V_64, V_32);
	}

	// Returns Some(op) if i fits in an immediate operand with width <= maxWidth
	// otherwise None
    def getImm32Operand(i: SsaInstr, maxWidth: ImmWidth) -> Maybe<Operand> {
        // null is 0 pointer
		if (i == null) { return Maybe.Some(Operand.Immediate(Int.box(0))); }
        // Can only use Imm32 if it is a constant
		if (SsaConst.?(i)) {
			def val = SsaConst.!(i).val;
			match (val) {
				null => { return Maybe.Some(Operand.Immediate(val)); } // Q: difference between useImm(null) and useInt(0)
				x: Box<int> => {
					// Check if x fits in maxWidth
					match (maxWidth) {
						Imm12 => if(x.val == i12.view(x.val)) return Maybe.Some(Operand.Immediate(x));
						Imm16 => if(x.val == i16.view(x.val)) return Maybe.Some(Operand.Immediate(x));
						Imm19 => if(x.val == i19.view(x.val)) return Maybe.Some(Operand.Immediate(x));
					}
				}
				x: Box<long> => context.fail("not implemented");
				x: Addr => context.fail("not implemented");
				x: Box<bool> => context.fail("not implemented");
				x: ArrayRangeStart => context.fail("not implemented"); // Q: what is this?
			}
		}
		return Maybe.None;
	}
}