// Copyright 2024 Virgil Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

component Arm64Targets {
	new() {
		Aeneas.registerTarget(Arm64Target.new("arm64", false));
	}
}

def SYS_exit: u16 = 0x1;

component Arm64Common {
	def LOWERING = makeMachLoweringConfig();
	def makeMachLoweringConfig() -> MachLoweringConfig {
		var config = MachLoweringConfig.new();
		config.Int32Arith = true;
		config.Int64Arith = true;
		config.ExplicitDivChecks = true;
		config.ExplicitModChecks = true;
		config.IntConvertFUnsigned = false; // no unsigned conversions until AVX?
		config.IntConvertFMapsNanToZero = false; // cvts{s,d}2si maps NaN to int.min
		config.IntConvertFPosSaturates = false; // cvts{s,d}2si returns int.min
		config.FloatConvertIUnsigned = false; // cvts{s,d}2si returns int.min
		return config;
	}

	def KERNEL_PARAM_REGS: Array<Arm64Reg> = [];

	def KERNEL_RETURN_REGS: Array<Arm64Reg> = [];

	def SPACE = AddressSpace.new("mem", false, 64, 8,
		Alignment.new(16384), Alignment.new(8));
}

// a mach-O thread state command for Arm64
class MachO_Arm64ThreadState extends MachO_LoadCmd {
	var pc: int; // Program counter
	def encode(is64: bool, w: DataWriter) {
		// unix thread
		w.put_b32(0x5);

		// 34 * 8 bytes for thread state + 4 * 4 for cmd, cmdSize, flavor, count
		w.put_b32(size(true));
		// Special flavor for Arm64
		w.put_b32(MachO.ARM64_THREAD_STATE_FLAVOR);
		// Number of words (4 bytes) in thread state
		w.put_b32(68);
		// Zero out registers
		w.zeroN(34 * 8);
		// Add pc
		var current_pos = w.pos;
		w.at(w.pos - 2 * 8);
		w.put_b64(pc);
		w.at(current_pos);
	}
	def size(is64: bool) -> int {
		return 34 * 8 + 4 * 4;
	}
}

class MachO_Arm64EntryPoint extends MachO_LoadCmd {
	var entryoff: int;
	def encode(is64: bool, w: DataWriter) {
		w.put_b32(0x28 | 0x80000000);
		w.put_b32(24);
		w.put_b64(entryoff);
		w.put_b64(0);
	}
	def size(is64: bool) -> int {
		return 24;
	}
}

class MachO_LinkEdit extends MachO_LoadCmd {
	var entryoff: int;
	def encode(is64: bool, w: DataWriter) {
		w.put_b32(0x1D);
		w.put_b32(4);
		w.put_b64(4);
		w.put_b64(16);
	}
	def size(is64: bool) -> int {
		return 4;
	}
}

def Regs: Arm64Regs;
def MRegs: Arm64RegSet;

class Arm64Target extends Target {
	def test: bool;
	def DEFAULT_VADDR_START: int = 0x08000000;

	new(name: string, test) super(name) { }

	def configureCompiler(compiler: Compiler) {}

	def configureProgram(prog: Program) {
		def space = Arm64Common.SPACE;
		def intNorm = IntNormalizers.I64LE;
		var mach = MachProgram.new(prog, space, space, intNorm);
		prog.tprog = mach;
		var rt = MachRuntime.new(mach);
		mach.runtime = rt;
		MachModule.install(prog, mach); // installs "Pointer" typecon
		DarwinModule.install(prog, true); // installs "Darwin" component
		prog.typeEnv.add(rt.typeCon); // installs "CiRuntime" component (for RiRuntime code)
	}

	def computeFieldOffsets(prog: Program, b: Vector<IrField>, start: int) {
		getRuntime(prog).mach.computeFieldOffsets(prog, b, start);
	}
	def addRoots(compiler: Compiler, prog: Program) {
		getRuntime(prog).addRoots();
	}

	def emit(compiler: Compiler, prog: Program) {
		var rt = getRuntime(prog), mach = rt.mach;
		mach.build(compiler, Arm64Common.LOWERING);

		var header = MachO_Header.new(true);
		var pageAlign = rt.codeRegion.space.pageAlign;
		header.cputype = MachO.CPU_TYPE_ARM64;
		header.cpusubtype = MachO.CPU_SUBTYPE_ARM64;
		header.filetype = MachO.MH_EXECUTE;

		var startAddr = int.view(CLOptions.VM_START_ADDR.get());
		if (startAddr == 0) startAddr = DEFAULT_VADDR_START;
		// protect page zero for trapping null accesses
		var pz = newSegmentLoad(header, "__NULL", 0);
		pz.vmsize = 0x100000000;
		// stack (data) segment if a non-zero stack size is specified
		var stackSize = pageAlign.alignUp64(int.!(CLOptions.STACK_SIZE.get()));
		if (stackSize > 0) {
			var ss = newSegmentLoad(header, "__STACK", MachO.VM_PROT_RW);
			ss.filesize = 0;
			ss.fileoff = 0;
			ss.vmsize = stackSize;
			ss.vmaddr = startAddr;
			rt.recordStackStart(startAddr);
			startAddr += stackSize;
			rt.recordStackEnd(startAddr);
		}
		// code (text) segment starts at page 1
		var cs = newSegmentLoad(header, "__TEXT", MachO.VM_PROT_RX);
		// data segment immediately follows code segment
		var ds = newSegmentLoad(header, "__DATA", MachO.VM_PROT_RW);
		var ls = newSegmentLoad(header, "__LINKEDIT", 1);
		// initial thread state for registers (includes starting IP)
		var ts = MachO_Arm64ThreadState.new();
		// var le = MachO_LinkEdit.new();
		header.addCmd(ts);
		// header.addCmd(le);
		// var ep = MachO_Arm64EntryPoint.new();
		// header.addCmd(ep);

		// ex segment for trapping explicit checks
		var ex = if(rt.src != null, newSegmentLoad(header, "__EX", 0));
		// create the buffer
		var w = MachDataWriter.new(rt.codeRegion.space.pageAlign,
			startAddr, 300 + mach.numMethods * 50);
		// skip mach-o headers
		w.skipN(header.totalsize);
		// skip page zero
		w.skipPage();
		// generate code and runtime tables into buffer
		// encodeCode(w, cs, ts);
		var backend = Arm64Backend.new(compiler, prog, mach, w, null, test);
		var endAddr = w.endAddr();
		// ep.entryoff = endAddr - w.startAddr; // TODO
		ts.pc = endAddr;

		cs.vmaddr = w.endPageAddr();
		rt.recordCodeStart(endAddr);
		backend.genAllCode();
		var size = w.end();
		if (size < pageAlign.size) {
			// TODO: Santa or MacOS rejects binaries with text segments smaller than a page!
			w.skipN(pageAlign.size - size);
		}
		rt.recordCodeEnd(w.endAddr());
		mach.layoutMeta(w);
		mach.layoutRuntime(w);
		cs.filesize = w.end();
		cs.vmsize = pageAlign.alignUp64(cs.filesize);
		cs.fileoff = 0;
		// generate the unmapped "ex" region for trapping explicit checks
		if (ex != null) {
			w.skipPage();
			var exStart = w.endPageAddr();
			var exSize = pageAlign.alignUp64(rt.src.layoutExRegion(exStart));
			w.startAddr = w.startAddr + exSize;
			ex.vmaddr = exStart;
			ex.vmsize = exSize;
			ex.filesize = 0;
			ex.fileoff = 0;
		}
		// generate data into buffer
		w.skipPage();
		// compute starting location of data
		w.atEnd().align(mach.data.addressSize);
		ds.vmaddr = w.endPageAddr();
		ds.fileoff = ds.vmaddr - w.startAddr;
		rt.recordDataStart(w.endAddr());
		mach.layoutData(w);
		rt.recordDataEnd(w.endAddr());
		rt.addHeapPointers(w);
		ds.filesize = w.end() - ds.fileoff;
		ds.vmsize = pageAlign.alignUp64(ds.filesize + int.view(rt.heapSize));

		w.skipPage();
		w.atEnd().align(mach.data.addressSize);
		ls.vmaddr = w.endPageAddr();
		ls.fileoff = ls.vmaddr - ds.vmaddr;
		ls.filesize = 16;
		ls.vmsize = pageAlign.alignUp(ds.filesize);
		// patch all addresses in the binary
		w.patch(backend.patchCodeAddr);
		// encode header at position 0 now that all addresses and offsets are known
		header.encode(w.at(0));
		header.encodeCmds(w);
		// open the output file
		var file = compiler.getOutputFileName(prog.name(), null);
		var fd = System.fileOpen(file, false);
		if (fd < 0) return prog.ERROR.OutputError(file);
		// write the entire file from the buffer array
		System.fileWriteK(fd, w.data, 0, w.end());
		System.fileClose(fd);
		// change permissions to make binary executable
		compiler.makeExecutable(file);
	}

	def newSegmentLoad(header: MachO_Header, name: string, prot: int) ->  MachO_SegmentLoad {
		var s = MachO_SegmentLoad.new(name);
		s.initprot = prot;
		s.maxprot = prot;
		header.addCmd(s);
		return s;
	}

	private def getRuntime(prog: Program) -> MachRuntime {
		return MachProgram.!(prog.tprog).runtime;
	}
}

// TODO: negative object headers
class Arm64Backend extends MachBackend {
	var asm: Arm64MacroAssembler; // TODO
	def test: bool;
	var codegen: SsaArm64Gen;
	var allocateRegs: void -> void;
	var allocateRegsGlobal: void -> void;

	// memory allocator configuration
	var objReg: Arm64Gpr;
	var sizeReg: Arm64Gpr;
	var ipReg: Arm64Gpr;
	var spReg: Arm64Gpr;
	var allocStubAddr: Addr;

	new(compiler: Compiler, prog: Program, mach: MachProgram, w: MachDataWriter, dwarf: Dwarf, test)
		super(compiler, prog, mach, w) {

		asm = Arm64MacroAssembler.new(w);

		codegen = SsaArm64Gen.new(context, mach, asm, w, dwarf);
		if (compiler.useGlobalRegAllocMatcher != VstMatcher.None) allocateRegsGlobal = GlobalRegAlloc.new(MRegs.SET, codegen).allocate;
		if (compiler.LocalRegAlloc) allocateRegs = LocalRegAlloc.new(MRegs.SET, codegen).allocate;
		else allocateRegs = SimpleRegAlloc.new(MRegs.SET, codegen).allocate;
	}

	// Override MachBackend	

	def genEntryStub() {
		asm_exit_code(0);
	}

	def genAllocStub() {
		mach.fail("not implemented");
	}

	def genCodeFromSsa() {
		mach.fail("not implemented");
	}

	def patchCodeAddr(w: DataWriter, a: Addr, posAddr: int) {
		mach.fail("not implemented");
	}

	def genSignalHandlerStub() {
		mach.fail("not implemented");
	}

	def genFatalStub(ex: string, addr: Addr) {
		mach.fail("not implemented");
	}

	// Methods overridden for each OS target
	def genSigHandlerInstall(signo: int, handler: Addr);
	def asm_exit_r(r: X86_64Gpr);

	def asm_exit_code(code: u16) {
		asm.movd_r_i(Regs.R0, code);
		asm.movd_r_i(Regs.R8, SYS_exit);
		asm.svc();
	}

	def genTestOutput(main: IrMethod, frame: MachFrame);

	// Helper functions

	// Returns call frame for an SsaGraph
	def getFrame(ssa: SsaGraph) -> MachFrame {
		return MachFrame.new(Arm64VirgilCallConv.getForGraph(mach, ssa), mach.data.addrAlign, mach.refSize);
	}

	// Adds Arm64 specific frame size to MachFrame
	// XXX 64 -bits for ever local, optimize?. Addition for return address?
	def computeFrameSize(frame: MachFrame) -> MachFrame {
		frame.frameSize = mach.alignTo(frame.slots() * mach.refSize + mach.code.addressSize, mach.stackAlign);
		return frame;
	}

	def genMainInit(frame: MachFrame) {
		mach.fail("not implemented");
	}
		
}