class SsaSpecializingRebuilder extends SsaRebuilder {
	def ssaPrinter = SsaPrinter.new();
	def irPrinter = IrPrinter.new(norm.ra.prog);
	def norm: ReachabilityNormalizer;
	def gen: VstSsaGen; // For recording direct calls
	// Current specializations. Map param indices to their subtype we specialize to.
	var	specs: Array<RaClass>;
	var specializedMethods: Vector<IrMethod> = Vector.new();
	var recordDirectCalls = true; // True the first time you call doSpecialization, then false

	new(context: SsaContext, norm: ReachabilityNormalizer, gen: VstSsaGen) super(context) {
		var numParams = context.graph.params.length;
		specs = Array.new(numParams);
	}

	def specialize() -> Vector<IrMethod> {
		// skip the receiver
		specializeParam(1, false);
		return specializedMethods;
		// return Vector.new();
	}
	def specializeParam(i: int, have_specialized: bool) {
		var params = context.graph.params;
		if (i == params.length) {
			// All specialization choices have been made
			if (have_specialized) doSpecialization();
			return;
		}

		var pt = params[i].getType();
		if (ClassType.?(pt)) {
			var rac = norm.ra.getClass(pt);
			var subtypes = rac.subtypes;
			var specializedParam = false;
			for (st = subtypes; st != null; st = st.tail) {
				if (st.head.newIrType == pt) continue; // Not a specialization
				specializedParam = true;
				specs[i] = st.head;
				specializeParam(i + 1, true);
			}
			if (!specializedParam) {
				// Continue specializing the rest of params
				specializeParam(i + 1, have_specialized);
			}
		} else {
			specializeParam(i + 1, have_specialized);
		}
	}
	def doSpecialization() {
		instrMap.reset(context.graph);
		var oldParams = context.graph.params;
		var numParams = oldParams.length;
		var newParams = Array<SsaParam>.new(numParams);
		var specialized = false;
		for (i < oldParams.length) {
			if (specs[i] != null) {
				// Specialize the parameter
				var st = specs[i];
				newParams[i] = SsaParam.new(numParams, st.normClass.ctype);
				specialized = true;
			}
			else
				// Common case, no change necessary
				newParams[i] = SsaParam.new(numParams, oldParams[i].vtype);
			map1(oldParams[i], newParams[i]);
		}
		if (!specialized) {
			return;
		}
		
		// create new graph
		newGraph = SsaGraph.new(newParams, context.graph.returnType);

		// Visit and generate new normalized code
		var oldStart = context.graph.startBlock;
		if (oldStart.succs().length == 0) {
			// common case of a single block that ends in return or throw
			// no need for blockmaps, queueing, or phi handling
			genBlock(oldStart, newGraph.startBlock);
		} else {
			// a method with multiple blocks
			genMultiBlock(oldStart, newGraph.startBlock);
		}
		var om = context.method;
		// TODO: Ugly indexing
		var newParamTypes = Array<Type>.new(numParams - 1);
		for (i < numParams - 1) {
			if (specs[i + 1] != null) {
				newParamTypes[i] = specs[i + 1].normClass.ctype;
			} else {
				newParamTypes[i] = om.sig.paramTypes[i];
			}
		}
		recordDirectCalls = false;
		var newMethod = IrMethod.new(om.receiver, om.typeArgs, Signature.new(null, newParamTypes, om.sig.returnTypes));
		newMethod.specialized = true;
		newMethod.source = om.source;
		newMethod.ssa = newGraph;
		norm.newIr.methods.put(newMethod);
		specializedMethods.put(newMethod);
		ssaPrinter.printGraph("Subtype Specialization", newMethod.render, newMethod.ssa, newMethod.sig);
	}
	// No normalization
	def normType(t: Type) -> TypeNorm {
		return null;
	}
	def genApplyOp(oi: SsaApplyOp) {
		curBlock.at(oi.source);
		var ni: SsaInstr;
		var specClass = getSpecClass(oi);
		if (specClass == null) {
			ni = curBlock.addApplyF(oi.op, genRefs(oi.inputs), oi.facts);	
			if (ni != null) {
				map1(oi, ni);
			} else {
				return V3.fail("unimplemented");
			}
			return;
		}
		var receiver = specClass.newIrType;
		match (oi.op.opcode) {
			CallClassSelector(selector) => {
				var specMeth = selector.mtable.table[specClass.minClassId - selector.mtable.rootId];
				var irSpec = extractSpecializedIrSpec(oi.op, specMeth, receiver);
				recordDirectCall(irSpec);
				ni = curBlock.addApplyF(V3Op.newCallClassMethod(irSpec), genRefs(oi.inputs), oi.facts);
			}
			ClassGetSelector(selector) => {
				var specMeth = selector.mtable.table[specClass.minClassId - selector.mtable.rootId];
				var irSpec = extractSpecializedIrSpec(oi.op, specMeth, receiver);
				ni = curBlock.addApplyF(V3Op.newClassGetMethod(irSpec), genRefs(oi.inputs), oi.facts);
			}
			ClassGetField(field) => {
				var irSpec = extractSpecializedIrSpec(oi.op, field, receiver);
				ni = curBlock.addApplyF(V3Op.newClassGetField(irSpec), genRefs(oi.inputs), oi.facts);
			}
			ClassSetField(field) => {
				var irSpec = extractSpecializedIrSpec(oi.op, field, receiver);
				ni = curBlock.addApplyF(V3Op.newClassSetField(irSpec), genRefs(oi.inputs), oi.facts);
			}
			TypeQuery => {
				ni = curBlock.opTypeQuery(receiver, oi.op.typeArgs[1], genRef1(oi.inputs[0]));
			}
			NullCheck => ni = curBlock.opNullCheck(receiver, genRef1(oi.inputs[0]));
			_ => ni = curBlock.addApplyF(oi.op, genRefs(oi.inputs), oi.facts);	
		}
		if (ni != null) {
			map1(oi, ni);
		} else {
			// block is already ended
			return V3.fail("unimplementeed");
		}
	}
	// Get the class to specialize this operation to, if there is one
	def getSpecClass(oi: SsaApplyOp) -> RaClass {
		if (SsaParam.?(oi.input0())) {
			var param = SsaParam.!(oi.input0());
			if (specs[param.index] != null) {	
				return specs[param.index];	
			}
		}
		return null;
	}
	// An IrSpec that specializes a member to a more specific receiver
	def extractSpecializedIrSpec(op: Operator, member: IrMember, receiver: Type) -> IrSpec {
		var newTypeArgs = Arrays.replace(op.typeArgs, 0, receiver);
		return IrSpec.new(receiver, newTypeArgs, member);	
	}
	def recordDirectCall(spec: IrSpec) {
		gen.directCallTargets = List.new(spec, gen.directCallTargets);
		if (gen.directCallBlocks == null || gen.directCallBlocks.head != curBlock.block) {
			// record the block if not already recorded
			gen.directCallBlocks = List.new(curBlock.block, gen.directCallBlocks);
		}
	}
}

class SsaSubtypeSpecializer {
	def ssaPrinter = SsaPrinter.new();
	def norm: ReachabilityNormalizer;
	private def specMap : HashMap<IrItem, Vector<IrMethod>> = IrUtil.newIrItemMap<Vector<IrMethod>>();

	new(norm: ReachabilityNormalizer) {}	

	def specializeMethod(context: SsaContext) {
		if (specMap.has(context.method)) {
			return;
		}

		var optContext = SsaContext.new(context.compiler, context.prog).enterMethod(context.method);
		var gen = VstSsaGen.new(optContext, context.prog.opBuilder);
		var rebuilder = SsaSpecializingRebuilder.new(context, norm, gen);
		var specializedMethods = rebuilder.specialize();
		if (specializedMethods.length > 0) {
			var meth = specializedMethods[0];
			optContext.enterSpec(IrSpec.new(meth.receiver, [meth.receiver], meth));
			SsaEarlyInliner.new(optContext, norm.ra.compilation, gen).inline(0);
		}
		for (i < specializedMethods.length) {
			var meth = specializedMethods[i];
			optContext.enterSpec(IrSpec.new(meth.receiver, [meth.receiver], meth));
			ssaPrinter.printGraph("Post-Inlined Subtype Specialization", meth.render, meth.ssa, meth.sig);
			SsaOptimizer.new(optContext).optGraph();
			ssaPrinter.printGraph("Post-Optimized Subtype Specialization", meth.render, meth.ssa, meth.sig);
		}
		specMap[context.method] = specializedMethods;
	}
	def getSpecializedMethods(m: IrMethod) -> Vector<IrMethod> {
		if (specMap.has(m)) {
			return specMap[m];
		}
		return Vector.new();
	}
	// Specialize method calls to specialized methods stored in specMap.
	def specializeCalls(m: IrMethod) {
		specializeBlockCalls(m.ssa.startBlock, Ssa.newBlockMap<void>());
	}
	def specializeBlockCalls(block: SsaBlock, visited: PartialMap<SsaBlock, void>) {
		if (visited.has(block)) return;
		visited[block] = ();

		for (instr = block.next; instr != block; instr = instr.next) {
			if (SsaApplyOp.?(instr)) {
				var apply = SsaApplyOp.!(instr);
				match (apply.op.opcode) {
					CallMethod(m) => {
						// Terminal.put1("Found method: %q\n", m.renderLong);
						var specializedMethods = getSpecializedMethods(m);
						var sm: IrMethod = null;
						for (i < specializedMethods.length) {
							if (isSpecializedMatch(apply, specializedMethods[i])) {
								sm = specializedMethods[i];
								break;
							}
						}
						if (sm != null) {
							// Terminal.put1("Specializing Method: %q\n", sm.renderLong);
							var inputs = Array<SsaInstr>.new(apply.inputs.length);
							for (i < inputs.length) inputs[i] = apply.inputs[i].dest;
							var newInstr = SsaApplyOp.new(apply.source, V3Op.newCallMethod(V3Op.extractIrSpec(apply.op, sm)), inputs);
							newInstr.next = instr.next;
							newInstr.prev = instr.prev;
							instr.prev.next = newInstr;
							instr.next.prev = newInstr;

							apply.replace(newInstr);
							apply.kill();
						}
					}
					_ =>;
				}
			}
		}
		for (succ in block.succs()) specializeBlockCalls(succ.dest, visited);
	}
	def isSpecializedMatch(apply: SsaApplyOp, m: IrMethod) -> bool {
		// Terminal.put1("Checking method: %q\n", m.renderLong);
		var args = apply.inputs;
		var params = m.ssa.params;
		if (args.length != params.length) {
			// Terminal.put2("Length mismatch: %d != %d\n", args.length, params.length);
			return false;
		}
		for (i < args.length) {
			var argType = args[i].dest.getType();
			if (argType != params[i].getType() && !AnyRefType.?(argType)) {
				// Terminal.put2("Type mismatch: %q != %q\n", argType.render, params[i].getType().render);
				return false;
				// TODO: handle subclassing
			}
		}
		return true;
	}
}