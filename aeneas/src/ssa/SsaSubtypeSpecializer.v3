class SsaSubtypeSpecializer extends SsaRebuilder {
	def ssaPrinter = SsaPrinter.new();
	def irPrinter = IrPrinter.new(norm.ra.prog);
	def norm: ReachabilityNormalizer;
	// Current specializations. Map param indices to their subtype we specialize to.
	var	specs: Array<RaClass>;

	new(context: SsaContext, norm: ReachabilityNormalizer) super(context) {
		var numParams = context.graph.params.length;
		specs = Array.new(numParams);
	}

	def specialize() {
		ssaPrinter.printGraph("Subtype Specialization before", context.method.render, context.graph, context.method.sig);
		// skip the receiver
		specializeParam(1);
	}
	def specializeParam(i: int) {
		var params = context.graph.params;
		if (i == params.length)
			// All specialization choices have been made
			return doSpecialization();

		var pt = params[i].getType();
		// Terminal.put1("%q\n", pt.render);
		if (ClassType.?(pt)) {
			var rac = norm.ra.getClass(pt);
			var subtypes = rac.subtypes;
			// irPrinter.printIrClass(rac.normClass);
			// Terminal.put1("Num subtypes: %d\n", Lists.length(rac.subtypes));
			if (Lists.length(subtypes) == 0) return specializeParam(i + 1);
			for (st = subtypes; st != null; st = st.tail) {
				specs[i] = st.head;
				specializeParam(i + 1);
			}
		}
	}
	def doSpecialization() {
		instrMap.reset(context.graph);
		var oldParams = context.graph.params;
		var numParams = oldParams.length;
		var newParams = Array<SsaParam>.new(numParams);
		for (i < oldParams.length) {
			if (specs[i] != null) {
				// Specialize the parameter
				var st = specs[i];
				// Terminal.put1("%q\n", subtype.normClass.ctype.render);
				newParams[i] = SsaParam.new(numParams, st.normClass.ctype);
			}
			else
				// Common case, no change necessary
				newParams[i] = SsaParam.new(numParams, oldParams[i].vtype);
			map1(oldParams[i], newParams[i]);
		}
		// create new graph
		newGraph = SsaGraph.new(newParams, context.graph.returnType);

		// Visit and generate new normalized code
		var oldStart = context.graph.startBlock;
		if (oldStart.succs().length == 0) {
			// common case of a single block that ends in return or throw
			// no need for blockmaps, queueing, or phi handling
			genBlock(oldStart, newGraph.startBlock);
		} else {
			// a method with multiple blocks
			genMultiBlock(oldStart, newGraph.startBlock);
		}
		var om = context.method;
		var newParamTypes = Array<Type>.new(numParams - 1);
		for (i < numParams - 1) {
			if (specs[i + 1] != null) {
				newParamTypes[i] = specs[i + 1].normClass.ctype;
			} else {
				newParamTypes[i] = om.sig.params[i + 1];
			}
		}
		var newMethod = IrMethod.new(om.receiver, om.typeArgs, )
		ssaPrinter.printGraph("Subtype Specialization after", context.method.render, newGraph, context.method.sig);
	}
	// No normalization
	def normType(t: Type) -> TypeNorm {
		return null;
	}
	def genApplyOp(oi: SsaApplyOp) {
		curBlock.at(oi.source);
		var specialized = false;
		var ni: SsaInstr;
		match (oi.op.opcode) {
			CallClassSelector(m) => {
				if (SsaParam.?(oi.input0())) {
					var param = SsaParam.!(oi.input0());
					if (specs[param.index] != null) {
						var receiver = specs[param.index].newIrType;
						var irSpec = IrSpec.new(receiver, [receiver], m.method); // TODO
						ni = curBlock.addApplyF(V3Op.newCallClassMethod(irSpec), genRefs(oi.inputs), oi.facts);
						specialized = true;
					}
				}
			}
			NullCheck => {
				if (SsaParam.?(oi.input0())) {
					var param = SsaParam.!(oi.input0());
					if (specs[param.index] != null) {
						var receiver = specs[param.index].newIrType;
						ni = curBlock.opNullCheck(receiver, genRef1(oi.inputs[0]));
						specialized = true;
					}
				}
			}
			_ =>;
		}
		if (!specialized) {
			ni = curBlock.addApplyF(oi.op, genRefs(oi.inputs), oi.facts);
		}
		if (ni != null) {
			map1(oi, ni);
		} else {
			// block is already ended
			return V3.fail("uh oh");
			// var vtype = context.spec.instantiateType(oi.getType());
			// instrMap[oi] = newGraph.nullConst(vtype);
		}
	}
}