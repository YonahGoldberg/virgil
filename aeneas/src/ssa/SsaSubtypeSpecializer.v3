class SsaSubtypeSpecializer extends SsaRebuilder {
	def ssaPrinter = SsaPrinter.new();
	def irPrinter = IrPrinter.new(norm.ra.prog);
	def norm: ReachabilityNormalizer;

	new(context: SsaContext, norm: ReachabilityNormalizer) super(context) {}

	def specialize() {
		ssaPrinter.printGraph("Subtype Specialization before", context.method.render, context.graph, context.method.sig);
		var m = context.method;
		for (i < m.sig.paramTypes.length) {
			var pt = m.sig.paramTypes[i];
			Terminal.put1("%q\n", pt.render);
			if (ClassType.?(pt)) {
				var rac = norm.ra.getClass(pt);
				irPrinter.printIrClass(rac.normClass);
				Terminal.put1("Num subtypes: %d\n", Lists.length(rac.subtypes));
				Lists.apply(rac.subtypes, doSpecialization(_, i));
			}
		}
	}

	def doSpecialization(subtype: RaClass, paramIndex: int) {
		// Normalize old parameters into new parameters
		instrMap.reset(context.graph);
		var oldParams = context.graph.params;
		var newParams = Vector<SsaParam>.new().grow(oldParams.length);
		var newRanges = Vector<(int,  int)>.new().grow(oldParams.length);
		var funcType = context.method.sig.funcType();
		for (i < oldParams.length) {
			var oldParam = oldParams[i];
			var start = newParams.length;
			if (i == paramIndex + 1) {
				// Specialize the parameter
				newParams.put(SsaParam.new(newParams.length, subtype.normClass.ctype));
			} else {
				// common case, no change necessary
				newParams.put(SsaParam.new(newParams.length, oldParam.vtype));
			}
			newRanges.put(start, newParams.length);
		}
		// Allocate new values for mapping the old params
		var newValues = Array<SsaInstr>.new(newParams.length);
		for (i < newParams.length) newValues[i] = newParams[i];

		// Create a new graph
		newGraph = SsaGraph.new(newParams.extract(), context.graph.returnType);

		// Map old parameters to new parameters
		for (i < newRanges.length) {
			var t = newRanges[i], size = t.1 - t.0;
			var oldParam = oldParams[i];
			if (size == 0) map0(oldParam);
			else if (size == 1) map1(oldParam, newValues[t.0]);
			else mapN(oldParam, Arrays.range(newValues, t.0, t.1));
		}

		// Visit and generate new normalized code
		var oldStart = context.graph.startBlock;
		if (oldStart.succs().length == 0) {
			// common case of a single block that ends in return or throw
			// no need for blockmaps, queueing, or phi handling
			genBlock(oldStart, newGraph.startBlock);
		} else {
			// a method with multiple blocks
			genMultiBlock(oldStart, newGraph.startBlock);
		}
		// if (true) SsaGraphVerifier.new(context, newGraph).verify();
		ssaPrinter.printGraph("Subtype Specialization after", context.method.render, newGraph, context.method.sig);
	}
	def normType(t: Type) -> TypeNorm {
		return null;
	}
	// def genValN(i_old: SsaConst, tn: TypeNorm, vec: Vector<SsaInstr>) {
	// 	vec.puta(mapValueN(i_old, i_old.val, tn));
	// }
	def genApplyOp(oi: SsaApplyOp) {
		// var op = oi.op.subst(context.spec.instantiateType);
		var ni = curBlock.at(oi.source).addApplyF(oi.op, genRefs(oi.inputs), oi.facts);
		if (ni != null) {
			map1(oi, ni);
		} else {
			// block is already ended
			var vtype = context.spec.instantiateType(oi.getType());
			instrMap[oi] = newGraph.nullConst(vtype);
		}
	}
}