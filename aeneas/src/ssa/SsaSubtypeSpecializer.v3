class SsaSubtypeSpecializer extends SsaRebuilder {
	def ssaPrinter = SsaPrinter.new();
	def irPrinter = IrPrinter.new(norm.ra.prog);
	def norm: ReachabilityNormalizer;
	// Current specializations. Map class types to their subtype we specialize to.
	def	specs = TypeUtil.newTypeMap<RaClass>();

	new(context: SsaContext, norm: ReachabilityNormalizer) super(context) {}

	def specialize() {
		ssaPrinter.printGraph("Subtype Specialization before", context.method.render, context.graph, context.method.sig);
		specializeParam(0);
	}
	def specializeParam(i: int) {
		var m = context.method;
		if (i == m.sig.paramTypes.length)
			// All specialization choices have been made
			return doSpecialization();

		var pt = m.sig.paramTypes[i];
		// Terminal.put1("%q\n", pt.render);
		if (ClassType.?(pt)) {
			var rac = norm.ra.getClass(pt);
			var subtypes = rac.subtypes;
			// irPrinter.printIrClass(rac.normClass);
			// Terminal.put1("Num subtypes: %d\n", Lists.length(rac.subtypes));
			if (Lists.length(subtypes) == 0) return specializeParam(i + 1);
			for (st = subtypes; st != null; st = st.tail) {
				specs[pt] = st.head;
				specializeParam(i + 1);
			}
		}
	}
	def doSpecialization() {
		instrMap.reset(context.graph);
		var oldParams = context.graph.params;
		var numParams = oldParams.length;
		var newParams = Array<SsaParam>.new(numParams);
		for (i < oldParams.length) {
			if (specs.has(oldParams[i].vtype)) {
				var st = specs[oldParams[i].vtype];
				// Specialize the parameter
				// Terminal.put1("%q\n", subtype.normClass.ctype.render);
				newParams[i] = SsaParam.new(numParams, st.normClass.ctype);
			}
			else
				// Common case, no change necessary
				newParams[i] = SsaParam.new(numParams, oldParams[i].vtype);
			map1(oldParams[i], newParams[i]);
		}
		// create new graph
		newGraph = SsaGraph.new(newParams, context.graph.returnType);

		// Visit and generate new normalized code
		var oldStart = context.graph.startBlock;
		if (oldStart.succs().length == 0) {
			// common case of a single block that ends in return or throw
			// no need for blockmaps, queueing, or phi handling
			genBlock(oldStart, newGraph.startBlock);
		} else {
			// a method with multiple blocks
			genMultiBlock(oldStart, newGraph.startBlock);
		}
		ssaPrinter.printGraph("Subtype Specialization after", context.method.render, newGraph, context.method.sig);
	}
	// No normalization
	def normType(t: Type) -> TypeNorm {
		return null;
	}
	def genApplyOp(oi: SsaApplyOp) {
		curBlock.at(oi.source);
		var ni: SsaInstr;
		match (oi.op.opcode) {
			CallClassSelector(m) => {
				if (SsaParam.?(oi.input0())) {
					var receiver = specs[m.receiver].newIrType;
					var irSpec = IrSpec.new(receiver, [receiver], m.method);
					ni = curBlock.addApplyF(V3Op.newCallClassMethod(irSpec), genRefs(oi.inputs), oi.facts);
				}
			}
			_ => ni = curBlock.addApplyF(oi.op, genRefs(oi.inputs), oi.facts);
		}
		if (ni != null) {
			map1(oi, ni);
		} else {
			// block is already ended
			var vtype = context.spec.instantiateType(oi.getType());
			instrMap[oi] = newGraph.nullConst(vtype);
		}
	}
}