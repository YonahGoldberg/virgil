class SsaSubtypeSpecializer extends SsaRebuilder {
	def ssaPrinter = SsaPrinter.new();
	def irPrinter = IrPrinter.new(norm.ra.prog);
	def norm: ReachabilityNormalizer;
	// Current specializations. Map param indices to their subtype we specialize to.
	var	specs: Array<RaClass>;

	new(context: SsaContext, norm: ReachabilityNormalizer) super(context) {
		var numParams = context.graph.params.length;
		specs = Array.new(numParams);
	}

	def specialize() {
		// skip the receiver
		specializeParam(1, false);
	}
	def specializeParam(i: int, have_specialized: bool) {
		var params = context.graph.params;
		if (i == params.length) {
			// All specialization choices have been made
			if (have_specialized) doSpecialization();
			return;
		}

		var pt = params[i].getType();
		if (ClassType.?(pt)) {
			var rac = norm.ra.getClass(pt);
			var subtypes = rac.subtypes;
			var specializedParam = false;
			for (st = subtypes; st != null; st = st.tail) {
				if (st.head.newIrType == pt) continue; // Not a specialization
				specializedParam = true;
				specs[i] = st.head;
				specializeParam(i + 1, true);
			}
			if (!specializedParam) {
				// Continue specializing the rest of params
				specializeParam(i + 1, have_specialized);
			}
		} else {
			specializeParam(i + 1, have_specialized);
		}
	}
	def doSpecialization() {
		instrMap.reset(context.graph);
		var oldParams = context.graph.params;
		var numParams = oldParams.length;
		var newParams = Array<SsaParam>.new(numParams);
		var specialized = false;
		for (i < oldParams.length) {
			if (specs[i] != null) {
				// Specialize the parameter
				var st = specs[i];
				newParams[i] = SsaParam.new(numParams, st.normClass.ctype);
				specialized = true;
			}
			else
				// Common case, no change necessary
				newParams[i] = SsaParam.new(numParams, oldParams[i].vtype);
			map1(oldParams[i], newParams[i]);
		}
		if (!specialized) {
			return;
		}
		
		// create new graph
		newGraph = SsaGraph.new(newParams, context.graph.returnType);

		// Visit and generate new normalized code
		var oldStart = context.graph.startBlock;
		if (oldStart.succs().length == 0) {
			// common case of a single block that ends in return or throw
			// no need for blockmaps, queueing, or phi handling
			genBlock(oldStart, newGraph.startBlock);
		} else {
			// a method with multiple blocks
			genMultiBlock(oldStart, newGraph.startBlock);
		}
		var om = context.method;
		// TODO: Ugly indexing
		var newParamTypes = Array<Type>.new(numParams - 1);
		for (i < numParams - 1) {
			if (specs[i + 1] != null) {
				newParamTypes[i] = specs[i + 1].normClass.ctype;
			} else {
				newParamTypes[i] = om.sig.paramTypes[i];
			}
		}
		var newMethod = IrMethod.new(om.receiver, om.typeArgs, Signature.new(null, newParamTypes, om.sig.returnTypes));
		newMethod.source = om.source;
		newMethod.ssa = newGraph;
		norm.newIr.methods.put(newMethod);
		ssaPrinter.printGraph("Subtype Specialization", newMethod.render, newMethod.ssa, newMethod.sig);
	}
	// No normalization
	def normType(t: Type) -> TypeNorm {
		return null;
	}
	def genApplyOp(oi: SsaApplyOp) {
		curBlock.at(oi.source);
		var specClass = getSpecClass(oi);
		var ni: SsaInstr;
		var receiver = specClass.newIrType;
		match (oi.op.opcode) {
			CallClassSelector(selector) => {
				var specMeth = selector.mtable.table[specClass.minClassId - selector.mtable.rootId];
				var irSpec = extractSpecializedIrSpec(oi.op, specMeth, receiver);
				ni = curBlock.addApplyF(V3Op.newCallClassMethod(irSpec), genRefs(oi.inputs), oi.facts);
			}
			ClassGetSelector(selector) => {
				var specMeth = selector.mtable.table[specClass.minClassId - selector.mtable.rootId];
				var irSpec = extractSpecializedIrSpec(oi.op, specMeth, receiver);
				ni = curBlock.addApplyF(V3Op.newClassGetMethod(irSpec), genRefs(oi.inputs), oi.facts);
			}
			ClassGetField(field) => {
				var irSpec = extractSpecializedIrSpec(oi.op, field, receiver);
				ni = curBlock.addApplyF(V3Op.newClassGetField(irSpec), genRefs(oi.inputs), oi.facts);
			}
			ClassSetField(field) => {
				var irSpec = extractSpecializedIrSpec(oi.op, field, receiver);
				ni = curBlock.addApplyF(V3Op.newClassSetField(irSpec), genRefs(oi.inputs), oi.facts);
			}
			NullCheck => ni = curBlock.opNullCheck(receiver, genRef1(oi.inputs[0]));
			_ => ni = curBlock.addApplyF(oi.op, genRefs(oi.inputs), oi.facts);	
		}
		if (ni != null) {
			map1(oi, ni);
		} else {
			// block is already ended
			return V3.fail("unimplementeed");
		}
	}
	// Get the class to specialize this operation to, if there is one
	def getSpecClass(oi: SsaApplyOp) -> RaClass {
		if (SsaParam.?(oi.input0())) {
			var param = SsaParam.!(oi.input0());
			if (specs[param.index] != null) {	
				return specs[param.index];	
			}
		}
		return null;
	}
	// An IrSpec that specializes a member to a more specific receiver
	def extractSpecializedIrSpec(op: Operator, member: IrMember, receiver: Type) -> IrSpec {
		var typeArgs = op.typeArgs;
		typeArgs[0] = receiver;
		return IrSpec.new(receiver, typeArgs, member);	
	}
}