// Arm64 registers come in 32-bit and 64-bit variants
type RegSize {
    case Half;
    case Full;
}

// Base class for all Arm64 registers
// regnum is an ID 0-32
class Arm64Reg(regnum: byte) {
	def low3 = byte.view(regnum & 0b111);
}

// Representation of an Arm64 general purpose register (x0-x30),
// or the zero register (xzr), or the stack pointer (sp).
// An "int reg", is not a standard name in the Arm64 reference, but we use it
// to distinguish from the SIMD and floating-point register file
class Arm64IntReg extends Arm64Reg {
	def name32: string;
	def name64: string;

	new(name32, name64, regnum) super(regnum) {}

	def name(size: RegSize) -> string {
		match (size) {
			Half => return name32;
			Full => return name64;
		}
	}
}

class Arm64Sfr extends Arm64Reg {} // TODO SIMD + floating point registers

// Global constants for all Arm64 Registers
component Arm64Regs {
    def R0 = Arm64IntReg.new("x0", "w0", 0);   def R1 = Arm64IntReg.new("x1", "w1", 1);
    def R2 = Arm64IntReg.new("x2", "w2", 2);   def R3 = Arm64IntReg.new("x3", "w1", 3);
    def R4 = Arm64IntReg.new("x4", "w4", 4);   def R5 = Arm64IntReg.new("x5", "w1", 5);
    def R6 = Arm64IntReg.new("x6", "w6", 6);   def R7 = Arm64IntReg.new("x7", "w1", 7);
    def R8 = Arm64IntReg.new("x8", "w8", 8);   def R9 = Arm64IntReg.new("x9", "w1", 9);
    def R10 = Arm64IntReg.new("x10", "w10", 10);   def R11 = Arm64IntReg.new("x11", "w11", 11);
    def R12 = Arm64IntReg.new("x12", "w12", 12);   def R13 = Arm64IntReg.new("x13", "w13", 13);
    def R14 = Arm64IntReg.new("x14", "w14", 14);   def R15 = Arm64IntReg.new("x15", "w15", 15);
    def R16 = Arm64IntReg.new("x16", "w16", 16);   def R17 = Arm64IntReg.new("x17", "w17", 17);
    def R18 = Arm64IntReg.new("x18", "w18", 18);   def R19 = Arm64IntReg.new("x19", "w19", 19);
    def R20 = Arm64IntReg.new("x20", "w20", 20);   def R21 = Arm64IntReg.new("x21", "w21", 21);
    def R22 = Arm64IntReg.new("x22", "w22", 22);   def R23 = Arm64IntReg.new("x23", "w23", 23);
    def R24 = Arm64IntReg.new("x24", "w24", 24);   def R25 = Arm64IntReg.new("x25", "w25", 25);
    def R26 = Arm64IntReg.new("x26", "w26", 26);   def R27 = Arm64IntReg.new("x27", "w27", 27);
    def R28 = Arm64IntReg.new("x28", "w28", 28);   def R29 = Arm64IntReg.new("x29", "w29", 29);
    def R30 = Arm64IntReg.new("x30", "w30", 30);   def SP = Arm64IntReg.new("sp", "wsp", 31);
    def RZR = Arm64IntReg.new("xzr", "wzr", 32);

    def INT_REGS = [
        R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10,
        R11, R12, R13, R14, R15, R16, R17, R18, R19, R20,
        R21, R22, R23, R24, R25, R26, R27, R28, R29, R30,
        SP, WZR
    ];
}

// a condition for use in jumps, set, and cmov
class Arm64Cond(name: string, index: int) {
	var negate: X86Cond;
	var commute: X86Cond;
}

// conditions for use in jumps, set, and cmov
component Arm64Conds {
    // TODO add the rest of the codes
    def EQ = Arm64Cond.new("eq", 0);
    def NEQ = Arm64Cond.new("neq", 1);
    def GT = Arm64Cond.new("gt", 2);
    def LT = Arm64Cond.new("lt", 3);

    def all = [EQ, NEQ, GT, LT];

	new() {
		// set up relations between conditions
        neg(EQ, NEQ);
        com(GT, LT);
	}

	def neg(a: Arm64Cond, b: Arm64Cond) {
		a.negate = b;
		b.negate = a;
	}

	def com(a: Arm64Cond, b: Arm64Cond) {
		a.commute = b;
		b.commute = a;
	}
}