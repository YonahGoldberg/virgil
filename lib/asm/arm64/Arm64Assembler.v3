// Arm64 registers come in 32-bit and 64-bit variants
type DataWidth {
	case Width32 { def mask() -> int { return 1 << 7 } };
	case Width64 { def mask() -> int { return 0 } };
}

// Possible right-hand side operands for many arm instructions.
type Arm64Operand {
	case Imm12(imm: u12);
	case Reg(rm: Arm64Reg);
	case RegLslImm(rm: Arm64Reg, shift: u6);
	case RegLsrImm(rm: Arm64Reg, shift: u6);
	case RegAsrImm(rm: Arm64Reg, shift: u6);
	case RegRorImm(rm: Arm64Reg, shift: u6);
}

// Base class for all Arm64 registers
// id is an ID 0-32
class Arm64Reg(id: u5) {}

// Representation of an Arm64 general purpose register (x0-x30),
// or the zero register (xzr), or the stack pointer (sp).
class Arm64Gpr extends Arm64Reg {
	def name32: string;
	def name64: string;

	new(name32, name64, id: u5) super(id) {}

	def name(size: RegSize) -> string {
		match (size) {
			Width32 => return name32;
			Width64 => return name64;
		}
	}
}

class Arm64Sfr extends Arm64Reg(0) {} // TODO SIMD + floating point registers

// Global constants for all Arm64 Registers
component Arm64Regs {
	def R0 = Arm64Gpr.new("x0", "w0", 0);		def R1 = Arm64Gpr.new("x1", "w1", 1);
	def R2 = Arm64Gpr.new("x2", "w2", 2);		def R3 = Arm64Gpr.new("x3", "w1", 3);
	def R4 = Arm64Gpr.new("x4", "w4", 4);		def R5 = Arm64Gpr.new("x5", "w1", 5);
	def R6 = Arm64Gpr.new("x6", "w6", 6);		def R7 = Arm64Gpr.new("x7", "w1", 7);
	def R8 = Arm64Gpr.new("x8", "w8", 8);		def R9 = Arm64Gpr.new("x9", "w1", 9);
	def R10 = Arm64Gpr.new("x10", "w10", 10);	def R11 = Arm64Gpr.new("x11", "w11", 11);
	def R12 = Arm64Gpr.new("x12", "w12", 12);   	def R13 = Arm64Gpr.new("x13", "w13", 13);
	def R14 = Arm64Gpr.new("x14", "w14", 14);   	def R15 = Arm64Gpr.new("x15", "w15", 15);
	def R16 = Arm64Gpr.new("x16", "w16", 16);   	def R17 = Arm64Gpr.new("x17", "w17", 17);
	def R18 = Arm64Gpr.new("x18", "w18", 18);   	def R19 = Arm64Gpr.new("x19", "w19", 19);
	def R20 = Arm64Gpr.new("x20", "w20", 20);   	def R21 = Arm64Gpr.new("x21", "w21", 21);
	def R22 = Arm64Gpr.new("x22", "w22", 22);   	def R23 = Arm64Gpr.new("x23", "w23", 23);
	def R24 = Arm64Gpr.new("x24", "w24", 24);   	def R25 = Arm64Gpr.new("x25", "w25", 25);
	def R26 = Arm64Gpr.new("x26", "w26", 26);   	def R27 = Arm64Gpr.new("x27", "w27", 27);
	def R28 = Arm64Gpr.new("x28", "w28", 28);   	def R29 = Arm64Gpr.new("x29", "w29", 29);
	def R30 = Arm64Gpr.new("x30", "w30", 30);   	def SP = Arm64Gpr.new("sp", "wsp", 31);
	def RZR = Arm64Gpr.new("xzr", "wzr", 32);

	def GPRS = [
		R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10,
		R11, R12, R13, R14, R15, R16, R17, R18, R19, R20,
		R21, R22, R23, R24, R25, R26, R27, R28, R29, R30,
		SP, RZR
	];
}

// One of the following forms:
// - [literal]
// - [base, imm disp] - base + disp
// - [base, reg offset, LSL leftShift]
class Arm64Addr(base: Arm64Gpr, offset: Arm64Gpr, shift: int, disp: int) {
	// TODO: Absolute? Plus?
	def absolute() -> bool { return base == null && offset == null; }
}

// a condition for use in jumps, set, and cmov
class Arm64Cond(name: string, index: int) {
	var negate: Arm64Cond;
	var commute: Arm64Cond;
}

// conditions for use in jumps, set, and cmov
component Arm64Conds {
	// TODO add the rest of the codes
	def EQ = Arm64Cond.new("eq", 0);
	def NEQ = Arm64Cond.new("neq", 1);
	def GT = Arm64Cond.new("gt", 2);
	def LT = Arm64Cond.new("lt", 3);

	def all = [EQ, NEQ, GT, LT];

	new() {
		// set up relations between conditions
		neg(EQ, NEQ);
		com(GT, LT);
	}

	def neg(a: Arm64Cond, b: Arm64Cond) {
		a.negate = b;
		b.negate = a;
	}

	def com(a: Arm64Cond, b: Arm64Cond) {
		a.commute = b;
		b.commute = a;
	}
}

// Abstract interface for recording and patching addresses in assembled code.
class Arm64AddrPatcher(absMarker: int, relMarker: int) {
	def recordAbs32(pos: int, addr: X86_64Addr) {}
	def recordRel32(pos: int, delta: int, addr: X86_64Addr) {}
}

// Labels can be used for assembling near and far relative branches.
class Arm64Label {
	var pos = -1;
	var near_uses: List<int>;
	var far_uses: List<int>;

	def bound() -> bool { return pos >= 0; }
}

// Abstract interface for recording and patching addresses in assembled code.
class Arm64AddrPatcher(absMarker: int, relMarker: int) {
	def recordAbs32(pos: int, addr: ArmAddr) {}
	def recordRel32(pos: int, delta: int, addr: ArmAddr) {}
}

class Arm64Assembler(w: DataWriter) {
	var patcher: Arm64AddrPatcher;

	def pos() -> int { return w.pos; }

	def mov(rd: ArmReg, rm: Arm64Reg, width: DataWidth) {
		emit(42 | width.mask() | (rm.id << 15) | rd.id);
	}

	def add(rd: Arm64Reg, rn: Arm64Reg, op: Arm64Operand, width: DataWidth) {
		emit_r_r_op(11, rd, rn, op);
	}
	def sub(rd: Arm64Reg, rn: Arm64Reg, op: Arm64Operand, width: DataWidth) {
		emit_r_r_op(162, rd, rn, op);
	}
	def udiv(rd: Arm64Reg, rn: Arm64Reg, Rm: Arm64Reg, width: DataWidth) {
		emit_r_r_r(0x1AC00800 | width.mask(), rd, rn, rm);
	}
	def sdiv(rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg, width: DataWidth) {
		emit_r_r_r(0x1AC00C00 | width.mask(), rd, rn, rm);
	}

	private def emit_r_r_op(opcode: u8, rd: Arm64Reg, rn: Arm64Reg, op: Arm64Operand) {
		var sh: = 0;
		var imm = 0;
		var reg = 0;

		match (op) {
			case Imm12(imm) => { imm = int.view(imm); }
			case Reg(rm: Arm64Reg) => { reg = rm.id; }
			case RegLslImm(rm: Arm64Reg, shift: u6) => { sh = 0; imm = int.view(shift); reg = rm.id; }
			case RegLsrImm(rm: Arm64Reg, shift: u6); => { sh = 1; imm = int.view(shift); reg = rm.id; }
			case RegAsrImm(rm: Arm64Reg, shift: u6); => { sh = 2; imm = int.view(shift); reg = rm.id; }
			case RegRorImm(rm: Arm64Reg, shift: u6); => { sh = 3; imm = int.view(shift); reg = rm.id; }
		}

		op_mask = (sh << 21) | (imm << 9) | (reg << 15);
		emit((int.view(opcode) << 23) | (int.view(rn.id) << 4) | op_mask);
	}

	private def emit_r_r_r(opcode: u32, rd: Arm64Reg, rn: Arm64Reg, rm: Arm64Reg) {
		emit(int.view(opcode) | int.view(rd.id) |
			(int.view(rn.id) << 4) | (int.view(rm.id) << 15));
	}

	private def emit(val: int) {
		w.put_b32(val);
	}
}